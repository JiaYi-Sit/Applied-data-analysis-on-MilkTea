---
title: "Project Closure"
author: "Xue"
date: "2025-03-16"
header-includes:
  - \usepackage{ctex}
output: 
  pdf_document: 
    include:
      keep_tex: yes
    latex_engine: xelatex
---
```{r}
# 加载必要的包
library(ggplot2)
library(readr)
library(scales)
library(chinamap)
library(dplyr)
data("chinamap", package = "chinamap")
library(hchinamap)
library(highcharter)
# 读取数据
Province <- read_csv("C:/Users/XUEJY/Desktop/Province_data.csv")
Tier <-read_csv("C:/Users/XUEJY/Desktop/tier_city.csv")
store_data <- read_csv("C:/Users/XUEJY/Desktop/new_open.csv")
brand_data <- read_csv("C:/Users/XUEJY/Desktop/storenumber.csv")
Month <- read_csv("C:/Users/XUEJY/Desktop/Monthopen.csv")
Tier_rate <- read_csv("C:/Users/XUEJY/Desktop/tier_rate.csv")
```
# 城市线级占比扇形图
```{r}
# Step 1: 转为数值
Tier_rate$占比 <- as.numeric(sub("%", "", Tier_rate$占比))

# Step 2: 设置图例顺序
Tier_rate$城市线级 <- factor(Tier_rate$城市线级,
                          levels = c("一线", "新一线", "二线", "三线", "四线", "五线", "其他"))

# Step 3: 控制饼图中扇区顺序
core_order <- c("一线", "新一线", "二线")

Tier_rate <- Tier_rate %>%
  mutate(是否核心 = 城市线级 %in% core_order) %>%
  arrange(desc(是否核心), match(城市线级, core_order), desc(占比)) %>%
  dplyr::select(-是否核心)  # 明确使用dplyr::select


# Step 4: 画图
ggplot(Tier_rate, aes(x = "", y = 占比, fill = 城市线级)) +
  geom_bar(stat = "identity", width = 1, color = "white") +
  coord_polar("y", start = 0) +
  scale_fill_brewer(palette = "Set3") +
  geom_text(
    aes(label = paste0(round(占比, 1), "%")),
    position = position_stack(vjust = 0.5),
    size = 3, color = "black"
  ) +
  labs(title = "城市线级占比分布") +
  theme_void() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    legend.position = "right"
  )
```

# 每月新增门店数-折线图
```{r}
library(tidyverse)
library(readr)

# 把“时间”列转换为日期
store_data <- store_data %>%
  mutate(月份 = as.Date(paste0(时间, "/01"), format = "%Y/%m/%d"))

# 整理成长表
df_long_new <- store_data %>%
  select(月份, 
         `蜜雪冰城` = `蜜雪冰城新增`,
         `古茗` = `古茗新增`,
         `喜茶` = `喜茶新增`,
         `奈雪的茶`=`奈雪的茶新增`) %>%
  pivot_longer(-月份, names_to = "品牌", values_to = "新增门店")

# 折线图：每月新增门店数
ggplot(df_long_new, aes(x = 月份, y = 新增门店, color = 品牌)) +
  geom_line(linewidth = 1.2) +
  geom_point(size = 1) +
  theme_minimal() +
  labs(title = "各品牌月度新增门店数", x = "时间", y = "新增门店数") +
  scale_x_date(date_breaks = "3 months", date_labels = "%Y-%m") +
    scale_color_manual(  # 手动指定颜色
    values = c(
      "蜜雪冰城" = "#FF6B6B", 
      "古茗" = "#355C7D",      
      "喜茶" = "#CD7F32",
      "奈雪的茶" = "#41B3A3"
    )
  )+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

# 每年总门店数-柱状图
```{r}
# 筛选“12月”作为年末总门店数记录
df_total <- store_data %>%
  filter(grepl("/12/", 时间)) %>%
  select(时间,
         `蜜雪冰城` = `蜜雪总数`,
         `古茗` = `古茗总数`,
         `茶百道` = `茶百道总数`,
         `喜茶` = `喜茶总数`,
         `奈雪的茶` = `奈雪总数`) %>%
  pivot_longer(-时间, names_to = "品牌", values_to = "总数")

# 提取年份
df_total <- df_total %>%
  mutate(年份 = substr(时间, 1, 4))

# 柱状图：品牌年末总门店数
ggplot(df_total, aes(x = 年份, y = `总数`, fill = 品牌)) +
  geom_col(position = "dodge") +
  scale_fill_manual(
  values = c(
    "#E27D60",  # 陶土橙
    "#85DCB0",  # 薄荷绿
    "#E8A87C",  # 浅卡其
    "#C38D9E",  # 灰紫色
    "#41B3A3"   # 蓝绿色
  )
) +
  theme_minimal() +
  labs(title = "各品牌年末总门店数对比", x = "年份", y = "总门店数")
```

# 客单价与门店数量气泡图
```{r}
library(ggimage)

ggplot(brand_data, aes(x = 门店总数, y = 平均价格)) +
  geom_image(aes(image = Logo), size = 0.11, alpha = 1.0) +
  coord_cartesian(xlim = c(0, max(brand_data$门店总数) * 1.4)) +
  geom_vline(xintercept = mean(brand_data$门店总数), 
             linetype = "dashed", color = "grey60") +
  geom_hline(yintercept = mean(brand_data$平均价格), 
             linetype = "dashed", color = "grey60") +
  labs(
    x = "门店数量", 
    y = "平均客单价 (元)", 
    title = "主要茶饮品牌：门店数量 vs 客单价"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(10, 10, 10, 10),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15)),
    axis.text.x = element_text(angle = 0, hjust = 0.5),
    legend.position = "none"
  )
```


# 年份-品牌-城市等级桑基图
```{r}
library(tidyverse)
# 包括 品牌、年份、各城市门店数和总门店数

library(dplyr)
library(tidyr)

# 第一部分：年份 → 品牌
year_to_brand <- Tier %>%
  mutate(source = as.character(年份),
         target = 品牌,
         value = 总门店数) %>%
  select(source, target, value)

# 第二部分：品牌 → 城市等级
brand_to_city <- Tier %>%
  pivot_longer(cols = c(一线城市门店数, 新一线城市门店数, 二线城市门店数, 三线城市门店数, 四线以下城市门店数),
               names_to = "city_level", values_to = "value") %>%
  mutate(source = 品牌,
         target = city_level) %>%
  select(source, target, value)

# 合并链接数据
links_data <- bind_rows(year_to_brand, brand_to_city)

print(links_data)
```

```{r}
library(networkD3)

right_order <- c("一线城市门店数", "新一线城市门店数", "二线城市门店数", 
                 "三线城市门店数", "四线以下城市门店数")

# 全部节点
all_nodes <- unique(c(links_data$source, links_data$target))

# 将节点分类
left_nodes   <- all_nodes[grepl("^20\\d{2}", all_nodes)]  # 年份节点
middle_nodes <- setdiff(setdiff(all_nodes, left_nodes), right_order)  # 品牌节点
right_nodes  <- right_order  # 城市线级节点，强制顺序
# 串联成完整的节点顺序
ordered_nodes <- c(left_nodes, middle_nodes, right_nodes)

# 生成 nodes 表
nodes <- data.frame(name = ordered_nodes)

# 为 links 分配 ID（顺序对应 nodes）
links <- links_data %>%
  mutate(
    source_id = match(source, nodes$name) - 1,
    target_id = match(target, nodes$name) - 1
  )
sankeyNetwork(Links = links,
              Nodes = nodes,
              Source = "source_id",
              Target = "target_id",
              Value = "value",
              NodeID = "name",
              fontSize = 12,
              nodeWidth = 30)


```
```{r}

# Step 1: 宽转长格式（pivot_longer）
Tier_long <- Tier %>%
  pivot_longer(
    cols = ends_with("城市门店数"),
    names_to = "城市线级",
    values_to = "门店数"
  )

# Step 2: 计算占比（每个品牌每年的线级门店数 / 总门店数）
Tier_long <- Tier_long %>%
  group_by(品牌, 年份) %>%
  mutate(占比 = 门店数 / sum(门店数)) %>%
  ungroup()

# Step 3: 设置城市线级顺序
Tier_long$城市线级 <- factor(Tier_long$城市线级,
                         levels = c("一线城市门店数", "新一线城市门店数",
                                    "二线城市门店数", "三线城市门店数",
                                    "四线以下城市门店数"))

# Step 4: 绘图（按品牌 faceting）
ggplot(Tier_long, aes(x = 年份, y = 占比, color = 城市线级)) +
  geom_line(linewidth = 1) +
  geom_point(size = 2) +
  facet_wrap(~ 品牌, ncol = 3) +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  scale_color_brewer(palette = "Set2") +
  labs(
    title = "2021–2025 各品牌在不同城市线级的门店占比趋势",
    x = "年份", y = "占比", color = "城市线级"
  ) +
  theme_minimal(base_size = 13)+
  theme(
    # 调整图例大小
    axis.text.x = element_text(angle = 45, hjust = 1),  # 旋转45度
    legend.key.size = unit(0.5, "lines"),  # 图例图标大小
    legend.text = element_text(size = 9), # 图例文字大小
    legend.title = element_text(size = 10)  # 图例标题大小
  )

```


# 分析省份层面的门店总数与常住人口数、人均可支配收入、地区之间的关系
```{r}
# 东南地区
Province <- Province %>%
  mutate(
    东南地区 = ifelse(
      省份 %in% c("上海", "江苏", "浙江","安徽","江西", "福建", "广东", "广西", "海南"), 1, 0
    )
  )

Regression <- Province %>%
  mutate(
    log_population = log(常住人口数),
    log_income = log(人均可支配收入),
    log_storecount = log(门店总数),
    东南地区
  )

# 拟合回归模型（对数-对数线性模型）
model <- lm(log_storecount ~ log_population + log_income + 东南地区, data = Regression)

# 查看回归结果
summary(model)
```


```{r}
library(broom) # 整理回归结果表格

#尝试区分南方与东南
Province <- Province %>%
  mutate(
    log_population = log(常住人口数),
    log_income = log(人均可支配收入),
    log_storecount = log(门店总数),
    区域类型 = case_when(
      省份 %in% c("广东", "广西", "海南","福建") ~ "华南",
      省份 %in% c("上海", "江苏", "浙江", "安徽", "江西") ~ "华东中",
      TRUE ~ "其他"
    )
  )
Province$区域类型 <- factor(Province$区域类型, levels = c("其他", "华东中", "华南"))
modeltest <- lm(log_storecount ~ log_population + log_income + 区域类型, data = Province)
summary(modeltest)
```

```{r}
library(car)
vif(modeltest)
```

# 反对数预测
```{r}
# 预测门店数量（是log门店数，要反对数）
Regression <- Province %>%
  mutate(
    pred_log_storecount = predict(modeltest),
    pred_storecount = exp(pred_log_storecount),
    residual = 门店总数 - pred_storecount,    # 真实 - 预测
    residual_rate = residual / pred_storecount  # 相对偏差
  )

# 查看预测与实际的对比
Regression %>%
  arrange(desc(residual_rate)) %>%
  select(省份, 门店总数, pred_storecount, residual, residual_rate)
```

```{r}
library(ggplot2)

ggplot(Regression, aes(x = 常住人口数, y = residual, size = 门店总数, color = residual_rate)) +
  geom_point(alpha = 0.7) +
  scale_size_continuous(range = c(3, 12)) +
  scale_color_gradient2(low = "white", mid = "blue", high = "red", midpoint = 0) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray") +
  coord_cartesian(  # 扩展坐标轴范围
    xlim = c(NA, max(Regression$常住人口数) * 1.1),
    ylim = c(NA, max(Regression$residual) * 1.1)
  )+
  labs(
    title = "省份潜力残差气泡图",
    x = "常住人口数（万）",
    y = "门店残差（真实-预测）",
    size = "门店总数",
    color = "残差率"
  ) +
  theme_minimal()
```

```{r}
# 潜力省份Top10表
Potential <- Regression %>%
  arrange(residual_rate) %>%
  slice(1:31) %>%
  select(省份, 门店总数, pred_storecount, residual, residual_rate)

print(Potential)
```

# 聚类分析
```{r}
library(cluster)
library(factoextra)# 用来画聚类结果图
library(ggrepel)

# 选择需要聚类的变量
cluster_data <- Province %>%
  select(常住人口数,人均可支配收入,门店密度, 蜜雪占比, 茶百道占比, 古茗占比, 喜茶占比)

# 标准化（避免量纲不一致）
cluster_data_scaled <- scale(cluster_data)
fviz_nbclust(cluster_data_scaled, kmeans, method = "wss")  # 看K的最佳取值
```


```{r}
# 聚类分析
set.seed(123)
km_res <- kmeans(cluster_data_scaled, centers = 4, nstart = 25)

# 将聚类标签加回原表
Province$cluster <- km_res$cluster

library(ggplot2)

p <- fviz_cluster(km_res, data = cluster_data_scaled, geom = "point", ellipse.type = "convex")

p + 
  geom_text_repel(
    aes(label = Province$省份), 
    size = 3,          # 字体大小
    box.padding = 0.5, # 标签与点之间的间距（默认0.25）
    max.overlaps = 20, # 允许的最大重叠次数（默认10）
    segment.color = "grey50", # 连接线颜色
    segment.size = 0.3,       # 连接线粗细
    direction = "both"        
  ) 
```

```{r}
# df 包含列 name（省份名）和 cluster（聚类结果）
hchinamap(name = Province$省份, value = as.numeric(Province$cluster),title = "各省聚类分组情况")
```

# 聚类-雷达图
```{r}
library(fmsb)

# 1. 聚类均值表
cluster_summary <- Province %>%
  group_by(cluster) %>%
  summarise(across(c(常住人口数, 人均可支配收入, 门店密度, 蜜雪占比, 茶百道占比, 古茗占比, 喜茶占比), mean))
print(cluster_summary)

# 2. 最大最小值行（雷达图要求）
max_min <- rbind(
  apply(cluster_summary[,-1], 2, max),
  apply(cluster_summary[,-1], 2, min)
)

# 3. 拼接数据
radar_data <- rbind(max_min, cluster_summary[,-1])

# 4. 设置行名为组名
rownames(radar_data) <- c("Max", "Min", paste0("Cluster ", 1:4))

# 5. 设置颜色（4组）
colors_border <- c("#6C5B7B", "#C06C84", "#355C7D", "#FFB347")        # 深色边框
colors_fill   <- paste0(colors_border, "33")                         # 透明填充色

# 6. 画图
par(mar = c(2, 2, 2, 2))  # 调整边距

radarchart(radar_data, axistype = 1, 
           pcol =  colors_border, pfcol = colors_fill,
           plwd = 2, plty = 1,
           cglcol="grey", cglty=1, axislabcol="grey", caxislabels=seq(0,1,0.2), cglwd=0.8,
           vlcex=0.8)

legend(x = 1.5, y = 1.1, legend = paste0("Cluster ", 1:4), 
       bty = "n", pch = 20, col = colors_border,
       text.col = "black", cex = 0.8, pt.cex = 1.5)

```

# 不同收入的省份，品牌占比假设检验
```{r}
Province$收入分组 <- ifelse(
  Province$`人均可支配收入` >= median(Province$`人均可支配收入`, na.rm = TRUE),
  "高收入",
  "低收入"
)

x1 <- Province$`喜茶占比`[Province$收入分组 == "高收入"]
x2 <- Province$`喜茶占比`[Province$收入分组 == "低收入"]

shapiro.test(x1)  # 高收入组品牌占比
shapiro.test(x2)  # 低收入组品牌占比

library(ggplot2)

ggplot(Province, aes(x = 收入分组, y = 喜茶占比)) +
  geom_boxplot(fill = "#FF9999") +
  labs(title = "不同收入省份的喜茶占比差异", x = "收入分组", y = "喜茶占比") +
  theme_minimal()

library(ggplot2)

ggplot(Province, aes(x = 收入分组, y = 蜜雪占比)) +
  geom_boxplot(fill = "lightblue") +
  labs(title = "不同收入省份的蜜雪占比差异", x = "收入分组", y = "蜜雪占比") +
  theme_minimal()

brand_list <- c("蜜雪占比", "古茗占比", "茶百道占比", "奈雪占比", "喜茶占比")

for (brand in brand_list) {
  cat("\n品牌：", brand, "\n")
  print(wilcox.test(Province[[brand]] ~ Province$收入分组))
}

```

##我们对五个主流现制茶饮品牌的门店占比在高收入与低收入省份之间的差异进行了 Wilcoxon 秩和检验。结果发现，喜茶（p \< 0.001）、奈雪（p=0.011）和蜜雪冰城（p=0.024）的门店占比在两类省份中存在显著差异。其中，高收入省份明显更偏好喜茶和奈雪等中高端品牌，而低收入省份则显示出对蜜雪冰城的更高偏好。古茗呈边缘性差异，而茶百道在两类省份中的占比无显著不同。

```{r}
##是否有季节性波动
library(dplyr)
library(lubridate)
library(tidyr)
library(tibble)

store_data$时间 <- as.Date(store_data$时间)  # 自动识别 "2025/3/1"
store_data$year <- year(store_data$时间)
store_data$month <- month(store_data$时间)

brand_list <- c("蜜雪冰城新增", "古茗新增", "喜茶新增", "茶百道新增")

for (brand in brand_list) {
  cat("\n品牌：", brand, "\n")
  df <- store_data %>%
    filter(year < 2025) %>%
    select(year, month, all_of(brand)) %>%
    tidyr::pivot_wider(names_from = month, values_from = all_of(brand)) %>%
    column_to_rownames("year")
  
  print(friedman.test(as.matrix(df)))
}
```


```{r}
ggplot(Province, aes(x = 门店密度, y = 蜜雪占比)) +
  geom_point(color = "tomato", size = 3) +
  geom_hline(yintercept = median(Province$蜜雪占比)) +
  geom_vline(xintercept = median(Province$蜜雪占比)) +
  geom_text(aes(label = 省份), vjust = -0.5, size = 3) +
  labs(title = "蜜雪冰城省份市场象限图", x = "茶饮门店密度", y = "市占率") +
  theme_minimal()
```

#高市占率 + 高密度：核心市场（维持） 
#低市占率 + 低密度：开发潜力区（重点扩张） #高密度但市占率低：被竞对压制（抢占） 
#市占率高但密度低：潜力待激活（深耕）

# 热力图
```{r}
# 要绘制的省份或城市
names <- c('北京', '上海', '江苏', '福建', '浙江', '天津', '广东', '内蒙古', 
          '湖北', '重庆', '山东', '陕西', '安徽', '湖南', '新疆', '辽宁', 
          '四川', '海南', '江西', '宁夏', '西藏', '山西', '云南', '青海', 
          '河南', '河北', '贵州', '吉林', '广西', '甘肃', '黑龙江')

# 对应的门店密度数据
values <- c(25.4672041, 30.87579528, 31.90241614, 39.66611018, 32.61169415, 23.87096774, 61.21674491, 21.00083752, 18.73157353, 21.52660893, 21.68533543, 19.78497344, 23.20757798, 21.02156293, 20.46286411, 21.66305656, 22.00143472, 74.70419847, 22.87644852, 21.86556927, 23.08108108, 17.44071318, 33.35338346, 27.01517707, 20.23331635, 18.81780062, 23.14507772, 38.84245095, 19.65209661, 19.28130364, 17.92619203)

values <- round(values, 2)

#对应门店总数的数据
values2 <- c(5560, 7658, 27200, 16632, 21752, 3256, 78235, 5015, 
            10928, 6868, 21952, 7821, 14210, 13746, 5367, 9001, 
            18402, 7829, 10299, 1594, 854, 6010, 15526, 1602, 
            19859, 13912, 8934, 4554, 23367, 4740, 5489)


# 导包
library(hchinamap)
library(IRdisplay)
library(htmlwidgets)
# 生成地图
map_widget <- hchinamap(name=names,
                        value=values,
                        width = "100%",
                        height = "650px",
                        title = "各省茶饮门店密度",
                        region = "China",
                        minColor = "#FFF5F0",
                        maxColor = "#CB181D",
                        itermName = "密度",
                        hoverColor = "#FFD700")
htmlwidgets::saveWidget(map_widget, "heatdensity.html")
browseURL("heatdensity.html")  # 在浏览器中打开


map_total <- hchinamap(
  name = names,
  value = values2,  # 门店总数数据
  width="100%",
  height="650px",
  title = "各省茶饮门店总数",
  region="China",
  minColor = "#E6F5FF",
  maxColor = "#003366",
  itermName="门店数量"
)

# 保存为 HTML 文件后查看
htmlwidgets::saveWidget(map_total, "heatmap.html")
browseURL("heatmap.html")  # 在浏览器中打开
```

```{r}
library(dplyr)
Province <- Province %>%
  mutate(
    竞争门店数 = 门店总数 - 蜜雪门店数,
    log_competition = log(竞争门店数),
    log_收入 = log(人均可支配收入 + 1),
    log_人口 = log(常住人口数 + 1),
    log_门店数 = log(门店总数 + 1),
  )
```


```{r}
Province$区域类型 <- factor(Province$区域类型, levels = c("其他", "华东中", "华南"))

model_competition <- glm(
  formula = 蜜雪门店数 ~ log_人口 + log_收入 + log_competition + 东南地区,
  family = poisson(link = "log"),
  data = Province
)
summary(model_competition)
```


```{r}
#负二项回归

library(MASS)
model_nb <- glm.nb(
  formula = 蜜雪门店数 ~ log_人口 + log_收入 + log_competition + 东南地区,
  data = Province
)

# 查看结果
summary(model_nb)
```


```{r}
Province$预测门店数 <- predict(model_nb, newdata = Province, type = "response")

# Step 2: 计算“潜力指数”（预测 / 当前）
Province$潜力指数 <- Province$预测门店数 / Province$蜜雪门店数

# Step 3: 排序并选择输出变量
预测表 <- Province %>%
  dplyr::select(省份, 蜜雪门店数, 预测门店数, 潜力指数, log_人口, log_收入, log_门店数, 东南地区) %>%
  arrange(desc(潜力指数)) %>%
  mutate(across(c(预测门店数, 潜力指数), ~ round(.x, 2)))


# 查看前几行
head(预测表)
```

```{r}
预测表 %>%
  pivot_longer(cols = c(蜜雪门店数, 预测门店数), names_to = "类型", values_to = "门店数") %>%
  ggplot(aes(x = 省份, y = 门店数, fill = 类型)) +
  geom_col(position = "dodge") +
  labs(title = "预测 vs 实际门店数比较", y = "门店数", x = NULL) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size=6))

```


```{r}
预测表 %>%
  arrange(desc(潜力指数)) %>%
  mutate(省份 = factor(省份, levels = 省份)) %>%
  ggplot(aes(x = 省份, y = 潜力指数, fill = 潜力指数)) +
  geom_col() +
  geom_text(aes(label = round(潜力指数, 2)), vjust = -0.3, size = 2) +
  scale_fill_gradient(low = "skyblue", high = "darkred") +
  labs(title = "各省蜜雪冰城开店潜力指数排序图", y = "潜力指数", x = NULL) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size=6))
```


```{r}
# 1. 计算“差值”列
预测表 <- 预测表 %>%
  mutate(
    差值 = round(预测门店数 - 蜜雪门店数),
    方向 = ifelse(差值 >= 0, "应扩张", "可能饱和")
  )

# 2. 按差值排序
预测表 <- 预测表 %>%
  arrange(差值) %>%
  mutate(省份 = factor(省份, levels = 省份))  # 保证按顺序画图

# 3. 绘图
ggplot(预测表, aes(x = 差值, y = 省份, fill = 方向)) +
  geom_col() +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray30") +
  scale_fill_manual(values = c("应扩张" = "#d73027", "可能饱和" = "#1a9850")) +
  labs(
    title = "各省蜜雪冰城门店布局偏离模型预测值",
    x = "预测门店数 - 实际门店数（单位：家）",
    y = NULL,
    fill = "战略建议"
  ) +
  theme_minimal(base_size = 13)+
  theme(
    axis.text.y = element_text(size = 6),  # 调整竖轴（省份）字体大小
    axis.text.x = element_text(size = 10)   # 顺带调整横轴字体（可选）
  )

```

